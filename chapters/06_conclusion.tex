\documentclass[a4paper, 12pt, dvipdfmx, uplatex]{jsreport}
\input{../preamble.tex}

\begin{document}
\chapter{おわりに}
\section{まとめ}
正規表現を非脆弱化するプログラムREMEDYと言語等価性判定器RegEqを用いて，ReDoS脆弱な正規表現を意味的に等価でかつ非脆弱なものに修正する手法を提案した．また，そのアルゴリズムを実装し，プログラムを走らせることでReDoS脆弱な正規表現を意味的な等しさを保ったまま非脆弱化することができた．

\section{今後の課題}
今回のアルゴリズムではREMEDYへの初回の入力を修正したい正規表現としていた．そうではなく次のような手法を試したい．まずはじめにRegEqにて正規表現$\varepsilon$と修正したい正規表現の比較を行い，そこで得られた反例と正規表現$\varepsilon$をREMEDYへの入力とする．得られた正規表現を修正したい正規表現とRegEqにて比較し，反例を得る．この工程を繰り返し行う．$\varepsilon$を基準に修正したい正規表現と等価な正規表現を生成していく流れとなる．$\varepsilon$から修正したい正規表現へと近づけていくのでよりサイズが小さく非脆弱な正規表現が得られる可能性がある．

また，RegEqの実装上，比較する2つの正規表現をどちらもDFAに変換している．しかし，本アルゴリズムでは修正元の正規表現は1回DFA化するだけで十分である．ループが繰り返されるたびにDFA化するのは非効率的なので今後改良したい．

さらに，そもそも等価性判定のアルゴリズムとして今回採用したものが適しているのかも疑問に残る．理由は2つある．1つ目は今回使用したアルゴリズムより効率よく等価性判定を行うことのできるものが存在するかもしれないからである．2つ目は等価性判定器が等価でないと決定する際に得られる反例が良いものでない可能性があるからである．しかし，現段階ではどのような例をREMEDYに渡すとより小さくより速く非脆弱な正規表現が得られるのかよく分かっていないので今後の課題としたい．

最後に，\ref{caution}節でも述べたとおり，character setを選択$|$でつなげた形に変換していた．この方法は恐らく計算量的に好ましくない．RegEqをcharacter setを直接扱えるように変更する，ないしはcharacter setを直接扱えるような言語等価性判定器を1から自作する必要があるだろう．

% \bibliography{main}
% \bibliographystyle{junsrt}
\end{document}